/*
NOTE FOR RELEASE MAINTAINERS:
This file only needs updating in the development release ("master" branch)
When documentation for stable releases is built,
the latest version from "master" is used
by https://git.yoctoproject.org/yocto-autobuilder-helper/tree/scripts/run-docs-build
*/

(function() {
  'use strict';

  var all_releases = {
	ALL_RELEASES_PLACEHOLDER
  };

  var switcher_versions = {
    VERSIONS_PLACEHOLDER
  };

  var latest_version =
    LATEST_VERSION_PLACEHOLDER
  ;

  var all_doctypes = {
      'single': 'Individual Webpages',
      'mega': "All-in-one 'Mega' Manual",
  };

  // Simple version comparision
  // Return 1 if a > b
  // Return -1 if a < b
  // Return 0 if a == b
  function ver_compare(a, b) {
    if (a == "dev") {
       return 1;
    }

    if (a === b) {
       return 0;
    }

    var a_components = a.split(".");
    var b_components = b.split(".");

    var len = Math.min(a_components.length, b_components.length);

    // loop while the components are equal
    for (var i = 0; i < len; i++) {
        // A bigger than B
        if (parseInt(a_components[i]) > parseInt(b_components[i])) {
            return 1;
        }

        // B bigger than A
        if (parseInt(a_components[i]) < parseInt(b_components[i])) {
            return -1;
        }
    }

    // If one's a prefix of the other, the longer one is greater.
    if (a_components.length > b_components.length) {
        return 1;
    }

    if (a_components.length < b_components.length) {
        return -1;
    }

    // Otherwise they are the same.
    return 0;
  }

  function build_version_select(current_version) {
    var buf = ['<select>'];

    // Start by pushing the versions from the the switcher_versions array,
    // unless our current version matches one of them, in which case this is
    // done last.
    $.each(switcher_versions, function (version, vers_data) {
      if (current_version != version) {
        buf.push(
          '<option value="' +
          version +
          '" selected="selected">' +
          vers_data['title'] +
          "</option>",
        );
      }
    });

    var current_title = current_version;
    var current_series = current_version.split("-")[0].split(".").slice(0, 2).join(".");
    if (current_version in switcher_versions) {
      current_title = switcher_versions[current_version]['title'];
    } else if (current_series in all_releases) {
      current_title = all_releases[current_series]['codename'] + ' (' + current_version + ')';
    }

    buf.push(
      '<option value="' +
        current_version +
        '" selected="selected">' +
        current_title +
        "</option>",
    );

    buf.push("</select>");
    return buf.join("");
  }
  }

  function build_doctype_select(current_doctype) {
    var buf = ['<select>'];

    $.each(all_doctypes, function(doctype, title) {
      if (doctype == current_doctype)
        buf.push('<option value="' + doctype + '" selected="selected">' +
                 all_doctypes[current_doctype] + '</option>');
      else
        buf.push('<option value="' + doctype + '">' + title + '</option>');
    });
    if (!(current_doctype in all_doctypes)) {
        // In case we're browsing a doctype that is not yet in all_doctypes.
        buf.push('<option value="' + current_doctype + '" selected="selected">' +
                 current_doctype + '</option>');
        all_doctypes[current_doctype] = current_doctype;
    }
    buf.push('</select>');
    return buf.join('');
  }

  function navigate_to_first_existing(urls) {
    // Navigate to the first existing URL in urls.
    var url = urls.shift();

    // Web browsers won't redirect file:// urls to file urls using ajax but
    // its useful for local testing
    if (url.startsWith("file://")) {
      window.location.href = url;
      return;
    }

    if (urls.length == 0) {
      window.location.href = url;
      return;
    }
    $.ajax({
      url: url,
      success: function() {
        window.location.href = url;
      },
      error: function() {
        navigate_to_first_existing(urls);
      }
    });
  }

  function get_docroot_url() {
    var url = window.location.href;
    // Try to get the variable from documentation_options.js
    var root = DOCUMENTATION_OPTIONS.URL_ROOT;
    if (root == null) {
      // In recent versions of Sphinx, URL_ROOT was removed from
      // documentation_options.js, so get it like searchtools.js does.
      root = document.documentElement.dataset.content_root;
    }

    var urlarray = url.split('/');
    // Trim off anything after '/'
    urlarray.pop();
    var depth = (root.match(/\.\.\//g) || []).length;
    for (var i = 0; i < depth; i++) {
      urlarray.pop();
    }

    return urlarray.join('/') + '/';
  }

  function on_version_switch() {
    var selected_version = $(this).children('option:selected').attr('value');
    var url = window.location.href;
    var current_version = DOCUMENTATION_OPTIONS.VERSION;
    var docroot = get_docroot_url()

    // If the current_version is X.Y-tip, we are currently browsing a branch
    // tip, and we need to convert it to the branch name.
    var current_version_split = current_version.split("-");
    if ((current_version_split.length > 1) && (current_version_split[1] == "tip")) {
      current_version = all_releases[current_version_split[0]]['codename'].toLowerCase();
    }

    if (selected_version == latest_version) {
      // default landing page selected, empty the version
      var new_versionpath = '';
    } else if (selected_version.includes("-tip")) {
      var branch_name = all_releases[selected_version.split("-")[0]]['codename'].toLowerCase();
      var new_versionpath = branch_name + '/';
    } else {
      var new_versionpath = selected_version + '/';
    }

    if (docroot.endsWith("dev/")) {
      var new_url = url.replace("/dev/", "/" + new_versionpath);
      var fallback_url = new_url.replace(url.replace(docroot, ""), "");
    } else if (docroot.endsWith(current_version + "/") == false) {
      var new_url = docroot + new_versionpath + url.replace(docroot, "");
      var fallback_url = docroot + new_versionpath;
    } else {
      var new_url = url.replace(
        "/" + current_version + "/",
        "/" + new_versionpath,
      );
      var fallback_url = new_url.replace(url.replace(docroot, ""), "");
    }

    console.log(get_docroot_url())
    console.log(url + " to url " + new_url);
    console.log(url + " to fallback " + fallback_url);

    if (new_url != url) {
      navigate_to_first_existing([
        new_url,
        fallback_url,
        'https://www.yoctoproject.org/docs/',
      ]);
    }
  }

  function on_doctype_switch() {
    var selected_doctype = $(this).children('option:selected').attr('value');
    var url = window.location.href;
    if (selected_doctype == 'mega') {
      var docroot = get_docroot_url()
      var current_version = DOCUMENTATION_OPTIONS.VERSION;
      // Assume manuals before 3.2 are using old docbook mega-manual
      if (ver_compare(current_version, "3.2") < 0) {
        var new_url = docroot + "mega-manual/mega-manual.html";
      } else {
        var new_url = docroot + "singleindex.html";
      }
    } else {
      var new_url = url.replace("singleindex.html", "index.html")
    }

    if (new_url != url) {
      navigate_to_first_existing([
        new_url,
        'https://www.yoctoproject.org/docs/',
      ]);
    }
  }

  // Returns the current doctype based upon the url
  function doctype_segment_from_url(url) {
    if (url.includes("singleindex") || url.includes("mega-manual"))
      return "mega";
    return "single";
  }

  $(document).ready(function() {
    var current_version = DOCUMENTATION_OPTIONS.VERSION;
    var current_doctype = doctype_segment_from_url(window.location.href);
    var version_select = build_version_select(current_version);

    $('.version_switcher_placeholder').html(version_select);
    $('.version_switcher_placeholder select').bind('change', on_version_switch);

    var doctype_select = build_doctype_select(current_doctype);

    $('.doctype_switcher_placeholder').html(doctype_select);
    $('.doctype_switcher_placeholder select').bind('change', on_doctype_switch);

    // First, check that the version is not one of: dev, next, or any "*-tip"
    if (!(["dev", "next"].includes(current_version)) && !(current_version.includes("-tip"))) {
      // We could be either: a fixed tag (X.Y[.Z]) or a floating commit (X.Y[.Z]-<hash>)
      var current_version_split = current_version.split("-");
      var current_version_no_hash = current_version_split[0];
      if (current_version_split.length > 1) {
        // We're on a floating commit, we don't care
        return;
      }
      var current_series = current_version_no_hash.split(".").slice(0, 2).join(".");
      var match = false;
      $.each(switcher_versions, function(version, vers_data) {
        var series = version.split("-")[0];
        if (current_series == series) {
          // Our version is part of the supported releases (switcher_versions)
          match = true;
          if (ver_compare(current_version_no_hash, all_releases[series]['latest_tag']) >= 0) {
            // Our version is higher or equal to the latest_tag from our series
            return;
          }
          $('#outdated-warning').html('This document is for an outdated tag ' + current_version + ', you should select version ' + all_releases[series]['codename'] + ' (' + all_releases[series]['latest_tag'] + ').');
          $('#outdated-warning').css('padding', '.5em');
          return;
        }
      });
      if (!match) {
        // Our version is not part of the supported releases (switcher_versions)
        $('#outdated-warning').html('This document is for obsolete release ' + current_version + ', you should select a supported release.');
        $('#outdated-warning').css('padding', '.5em');
      }
    }
  });
})();
